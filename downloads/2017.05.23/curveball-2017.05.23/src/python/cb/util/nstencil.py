#!/usr/bin/env python
#
# This material is based upon work supported by the Defense Advanced
# Research Projects Agency under Contract No. N66001-11-C-4017.
#
# Copyright 2014 - Raytheon BBN Technologies Corp.
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or
# implied.  See the License for the specific language governing
# permissions and limitations under the License.

"""
Decodes ciphertext created by cb_stencil to recover the 
stencilized secret
"""

import hashlib

class StencilDecoder(object):
    """
    Simple stencil decoder.

    Does not implement encryption.  Trying to use a non-empty
    key will raise an execption.
    """

    # These constants MUST exactly match those in
    # nss/lib/curveball/cb_stencil.[ch].

    BITS_PER_BYTE = 8

    BLKSIZE_NBYTES = 16
    NBITS = (2 + 32) * BITS_PER_BYTE
    NBITS_PER_BLK = 8

    NBYTES = NBITS / BITS_PER_BYTE

    BLKSIZE_NBITS = BLKSIZE_NBYTES * BITS_PER_BYTE

    MASK_NBYTES = (BLKSIZE_NBYTES * NBITS) / NBITS_PER_BLK
    MASK_NBITS = MASK_NBYTES * BITS_PER_BYTE

    def __init__(self, key=''):

        if key:
            raise NotImplementedError('keys not supported yet')
        else:
            self.xor = chr(0) * self.NBYTES

        self.spec = self.default_spec()

    @staticmethod
    def default_spec():
        """
        Set the spec to be the default, without any encryption.
        """

        spec = list()
        n_blks = StencilDecoder.NBITS / StencilDecoder.NBITS_PER_BLK

        first_offset_in_blk = (StencilDecoder.BITS_PER_BYTE *
                (StencilDecoder.BLKSIZE_NBYTES - StencilDecoder.NBITS_PER_BLK))

        blk = 0
        while blk < n_blks:
            ind = 0

            while ind < StencilDecoder.NBITS_PER_BLK:
                spec.append(first_offset_in_blk +
                        (blk * StencilDecoder.BLKSIZE_NBITS) +
                        (ind * StencilDecoder.BITS_PER_BYTE))
                ind += 1
            blk += 1

        return spec

    def decode(self, data_str):
        """
        Decode the given data_str, using the current spec, without any
        encryption.
        """       
        res_list = list()
        curr_byte = 0
        curr_bit = 0
        for ind in self.spec:
            byte_offset = ind / self.BITS_PER_BYTE
            bit_offset = ind % self.BITS_PER_BYTE

            try:
                if ord(data_str[byte_offset]) & (1 << bit_offset):
                    curr_byte |= 1 << curr_bit
            except IndexError:
                print "IndexError in nstencil decode"
                print data_str
                print byte_offset
                print bit_offset
                print len(data_str)
                
            curr_bit += 1
            if curr_bit == self.BITS_PER_BYTE:
                res_list.append(chr(curr_byte))
                curr_byte = 0
                curr_bit = 0

        return ''.join(res_list)

    def decode_with_ciphersuite(self, data_str):
        """
        Decode the given data_str, using the current spec, without any
        encryption.  The result is assumed to represent a ciphersuite
        (the first two bytes, with the first byte representing the
        lower 8 bits and the second the upper 8 bits) followed by the
        ServerRandom value (the next 32 bytes)

        returns (ciphersuite, serverrandom)
        """

        data = self.decode(data_str)
        return (ord(data[0]) + (ord(data[1]) << 8), data[2:self.NBYTES])

class EncryptedStencilDecoder(StencilDecoder):
    """
    A decoder for encrypted stencils.

    The basic mechanism is the same as for an ordinary StencilDecoder,
    except that the stencil data itself is encrypted prior to being
    placed in the stencil.

    The encryption is to xor the bits of the stencil data with a
    pseudo-random function (PRF) generated from the key.  The PRF
    is defined generated by the following expansion of the key:
    nth 512 bits of the PRF are sha512(key * n).
    """

    def __init__(self, key):
        super(EncryptedStencilDecoder, self).__init__()

        # NOTE: we assume that the key is strong and of reasonable
        # length, and we don't check.  If you use a short key,
        # you're going to get weak crypto.
        #
        self.key = key

        prf_output = ''

        iteration = 1
        while len(prf_output) < self.NBYTES:
            hashstate = hashlib.sha512()
            hashstate.update(key * iteration)
            prf_output += hashstate.digest()
            iteration += 1

        # Trim off any extra inflation
        #
        self.inflated_key = prf_output[:self.NBYTES]

        # print 'inflated key: %s' % self.inflated_key.encode('hex')

    def decode(self, data_str):
        """
        Decode the data_str from the stencil, and then decrypt the result
        """

        enc_data = super(EncryptedStencilDecoder, self).decode(data_str)

        # print 'enc_data was %s' % enc_data.encode('hex')

        dec_data = ''.join(
                [chr(ord(enc_data[i]) ^ ord(self.inflated_key[i]))
                    for i in xrange(self.NBYTES)])

        return dec_data


if __name__ == '__main__':

    def test_decode(decoder):
        """
        Test the decoder on several simple patterns

        Needs to be examined by eyeball; not automated
        """

        print 'All low-order bits 1:'
        data = "a" * decoder.MASK_NBYTES
        print decoder.decode(data).encode("hex")

        print 'All low-order bits 0:'
        data = "b" * decoder.MASK_NBYTES
        print decoder.decode(data).encode("hex")

        print 'Alternating 1/0'
        data = "ab" * (decoder.MASK_NBYTES / 2)
        print decoder.decode(data).encode("hex")

        print 'Alternating 0/1'
        data = "ba" * (decoder.MASK_NBYTES / 2)
        print decoder.decode(data).encode("hex")

        print 'Alternating 11/00'
        data = "aabb" * (decoder.MASK_NBYTES / 4)
        print decoder.decode(data).encode("hex")

        print 'Alternating 1111/0000'
        data = "aaaabbbb" * (decoder.MASK_NBYTES / 8)
        print decoder.decode(data).encode("hex")

    def test_main():
        """
        skeleton of a test driver.

        Not automated; requires eyeballing.
        """

        print ' Testing unencrypted decoder'
        decoder = StencilDecoder()
        test_decode(decoder)

        # TODO: This doesn't test anything useful yet.
        print ' Testing encrypted decoder'
        decoder = EncryptedStencilDecoder('abcdabcdabcdabcd')
        test_decode(decoder)

        # The input is the hex representation of a ciphertext that
        # would be passed to the stencil decoder.
        # The hex_ciphertext should decode to the given input_hex
        #
        input_hex = '350053885eec8694ac0f19f1b5b22cc1dc1591e7d75959f1b5a3603da840d56d8ace'
        hex_ciphertext = '1be78aecb98dd87ed23ae97082da214aea81c4f8248cdba5a56724560a152529bf0db2fefac01b00301a65361bdabdfde27333953ce7c9a6c3f802bc6ea3d396de002e0ff618633378f4a659c12ee14b733e1f862750e9afba3c28e5d486f06bacf3987368fc82c84db880d3248068f739680e8b75a2e19acbf7669f57ee2c808f98c2294d19b96622e3ea0e942d293a8064cb656dc6c56b8593d0b155ae7635507f3ba5a2bf9f9dad47ccbfdb07b34ea865903ca98a4db21b5417443f1fb8be9afa3bdd391533ef31e53b0ddd5d542ffa8182bae4dd31132a25c612e3e41f69e08ffe762353e355ebb4cb1e8f375a23b1155f80118b7cd4302c282d8e28ae7f6ad177248ca5e0477b3aa9dc6572f6b50bf28d62d68e33c35a003d1cfac0bab1560498f83e7c80438b9981456d33f3e486b0da4a4be30edb9a0fb42d4ac0235bdf0373ed8a8abd971e1ccdfa9baa2adec392775d13e970dd638c7b5cbd3035ceba7f70d9cd0e7aa867f9fd01b23f679c76f8f821415b86187931fe22f9046843a767cd2afe782627f06ea17e9b32e437d8769c647290961a3fb956f372cea48ccabf5753e07c4b81a6ea05d0d00d3ce28368ccf17df47e9d0fba988780299d60a57c98a8540a6fff316326a0e278f95d9b7da4a27f4fddea92b9df5715dc1e104c902e2aa35850dd90a3dfc17da1b5ac65e0cfbc454d92e500bde6968bafe3332e03bf5e6a7bd7fc1cea745e6b00bba962e5ec5428dd5b5ea1ab21792d5539e0'

        bin_ciphertext = hex_ciphertext.decode('hex')
        print len(bin_ciphertext)

        value = decoder.decode(bin_ciphertext)
        if value.encode('hex') != input_hex:
            print 'FAILED'

    test_main()

