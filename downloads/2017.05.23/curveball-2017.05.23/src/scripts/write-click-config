#!/usr/bin/env python
#
# This material is funded in part by a grant from the United States
# Department of State. The opinions, findings, and conclusions stated
# herein are those of the authors and do not necessarily reflect
# those of the United States Department of State.
#
# Copyright 2016 - Raytheon BBN Technologies Corp.
#
# Licensed under the Apache License, Version 2.0 (the "License"); you
# may not use this file except in compliance with the License.
#
# You may obtain a copy of the License at
# http://www.apache.org/licenses/LICENSE-2.0.
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or
# implied. See the License for the specific language governing
# permissions and limitations under the License.

"""
Writes the contents of the Decoy Router Click router configuration file
given the configured number of Decoy Proxy connections.

Very simple; intended to be used internally by the cb-dr script.
"""

import sys

def write_header():
    lines_of_text = """\
/* Generated by write-click-config
 *
 * This material is funded in part by a grant from the United States
 * Department of State. The opinions, findings, and conclusions stated
 * herein are those of the authors and do not necessarily reflect
 * those of the United States Department of State.
 *
 * Copyright 2016 - Raytheon BBN Technologies Corp.
 *
 * Licensed under the Apache License, Version 2.0 (the \"License\"); you
 * may not use this file except in compliance with the License.
 *
 * You may obtain a copy of the License at
 * http://www.apache.org/licenses/LICENSE-2.0.
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an \"AS IS\" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or
 * implied. See the License for the specific language governing
 * permissions and limitations under the License.
 */
    """
    return lines_of_text

def write_config(num_proxies):
    lines_of_text = """
require(package "curveball");

define($FORWARD_DEV netmap:eth4,
       $REVERSE_DEV netmap:eth5,
       $TLS_PORT 443,
       $UDP_PORT 9,
       $UDP_SRC_ADDR 10.0.0.32,
       $STAT_INTERVAL 1,
       $MAX_ZERO_INTERVAL 10)

forward_classifier :: Classifier(12/0800,
                                 12/8100 16/0800,
                                 -)
reverse_classifier :: Classifier(12/0800, -)

forward_ip_classifier :: IPClassifier(dst tcp port $TLS_PORT,
                                      icmp,
                                      dst udp port $UDP_PORT,
                                      -)
reverse_ip_classifier :: IPClassifier(icmp, -)

tls_flow_detector       :: TLSFlowDetector(PORT $TLS_PORT,
                                           ENCODER dr2dp_encoder,
                                           UDP_PORT $UDP_PORT,
                                           UDP_SRC_ADDR $UDP_SRC_ADDR,
                                           REVERSE false)

forward_icmp_processor  :: ICMPProcessor(DETECTOR tls_flow_detector)
reverse_icmp_processor  :: ICMPProcessor(DETECTOR tls_flow_detector)

udp_receiver            :: UDPReceiver(PORT $UDP_PORT,
                                       IPADDR $UDP_SRC_ADDR,
                                       DETECTOR tls_flow_detector)

dr2dp_encoder :: DR2DPEncoder(DETECTOR tls_flow_detector)
    """
    config_output = [lines_of_text]

    for x in range(0, (num_proxies - 1)):
        line = "dr2dp_decoder%d :: DR2DPDecoder(DETECTOR tls_flow_detector)" % x
        config_output.extend([line])

    lines_of_text = """\
dr2dp_decoder%d :: DR2DPDecoder(DETECTOR tls_flow_detector,
                               FILTER_FILENAME /tmp/sentinel_filter,
                               BLACKLIST_FILENAME /tmp/bad_dh_list)
    """ % (num_proxies - 1)
    config_output.extend([lines_of_text])

    for x in range(0, num_proxies):
        line = "decoy_proxy%d :: Socket(UNIX, '/tmp/curveball%d', " \
               "CLIENT true, HEADROOM 0)" % (x, x)
        config_output.extend([line])

    lines_of_text = """
forward_incoming :: FromNetmapDevice($FORWARD_DEV, PROMISC true)
forward_outgoing :: ToNetmapDevice($REVERSE_DEV)
forward_incoming
        -> CBPacketStats(LABEL "Incoming",
                         INTERVAL $STAT_INTERVAL,
                         MAX_ZERO_INTERVAL $MAX_ZERO_INTERVAL)
        -> forward_classifier;

reverse_incoming :: FromNetmapDevice($REVERSE_DEV, PROMISC true)
reverse_outgoing :: ToNetmapDevice($FORWARD_DEV)
reverse_incoming -> reverse_classifier;

// IPv4 traffic
forward_classifier[0]
        -> CBStripEther()
        -> MarkIPHeader()
        -> forward_ip_classifier;
forward_classifier[1]
        -> CBStripEther()
        -> MarkIPHeader()
        -> forward_ip_classifier;
reverse_classifier[0]
        -> CBStripEther()
        -> MarkIPHeader()
        -> reverse_ip_classifier;

// non-IPv4 traffic
forward_classifier[2] -> forward_outgoing;
reverse_classifier[1] -> reverse_outgoing;

// TLS
forward_ip_classifier[0]
        -> CBPacketStats(LABEL "TLS",
                         INTERVAL $STAT_INTERVAL,
                         TCP true)
        -> [0]tls_flow_detector;

SimpleIdle -> [1]tls_flow_detector;     // no incoming reverse traffic

tls_flow_detector[0]            // Curveball
        -> dr2dp_encoder;
    """
    config_output.extend([lines_of_text])

    for x in range(0, num_proxies):
        line = "dr2dp_encoder[%d] -> decoy_proxy%d;" % (x, x)
        config_output.extend([line])

    lines_of_text = """
tls_flow_detector[1]            // Non-Curveball
        -> CBUnstripEther()
        -> forward_outgoing;

tls_flow_detector[2]            // UDP Notifications
        -> forward_outgoing;

tls_flow_detector[3]            // Reverse Traffic
        -> CBUnstripEther()
        -> reverse_outgoing;

// ICMP
forward_ip_classifier[1]
        -> forward_icmp_processor
        -> CBUnstripEther()
        -> forward_outgoing;

reverse_ip_classifier[0]
        -> reverse_icmp_processor
        -> CBUnstripEther()
        -> reverse_outgoing;

// UDP
forward_ip_classifier[2]
        -> udp_receiver
        -> CBUnstripEther()
        -> forward_outgoing;

// everything else
forward_ip_classifier[3] -> CBUnstripEther() -> forward_outgoing;
reverse_ip_classifier[1] -> CBUnstripEther() -> reverse_outgoing;
    """
    config_output.extend([lines_of_text])

    for x in range(0, num_proxies):
        line1 = "decoy_proxy%d -> dr2dp_decoder%d;" % (x, x)
        line2 = "dr2dp_decoder%d[0] -> forward_outgoing;" % x
        line3 = "dr2dp_decoder%d[1] -> reverse_outgoing;\n" % x
        config_output.extend([line1, line2, line3])

    return config_output


def main(argv):
    """
    Parse argv to determine the number of decoy proxy connections.

    Write the contents of the decoy router click configuration file.
    """

    if len(argv) != 3:
        print 'ERROR: usage: %s num_proxies outfile' % argv[0]
        sys.exit(1)

    num_proxies = int(argv[1])
    if num_proxies < 1:
        print 'ERROR: %s: invalid number of proxies %s' % \
            (argv[0], str(num_proxies))
        sys.exit(1)

    out_fname = argv[2]

    try:
        fh = open(out_fname, 'w+')
    except BaseException, exc:
        print 'ERROR: %s: %s' % (argv[0], str(exc))
        sys.exit(1)

    header = write_header()
    fh.write(header)

    config = write_config(num_proxies)
    fh.write('\n'.join(config))

    fh.close()

if __name__ == '__main__':
    exit(main(sys.argv))
